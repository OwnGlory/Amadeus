WindowLen = 256;
AnalysisLen = 64;
SynthesisLen = 90;
Hopratio = SynthesisLen/AnalysisLen;

reader = dsp.AudioFileReader('SpeechDFT-16-8-mono-5secs.wav', ...
  'SamplesPerFrame',AnalysisLen, ...
  'OutputDataType','double');

win = sqrt(hanning(WindowLen,'periodic'));
stft = dsp.STFT(win, WindowLen - AnalysisLen, WindowLen); 
istft = dsp.ISTFT(win, WindowLen - SynthesisLen );

Fs = 44100;
player = audioDeviceWriter('SampleRate',Fs, ...
    'SupportVariableSizeInput',true, ...
    'BufferSize',512);

logger = dsp.SignalSink;

unwrapdata = 2*pi*AnalysisLen*(0:WindowLen-1)'/WindowLen;
yangle = zeros(WindowLen,1);
firsttime = true;

while ~isDone(reader)
 y = reader();

 player(y); % Play back original audio

    % ST-FFT
 yfft = stft(y);
 
 % Convert complex FFT data to magnitude and phase.
 ymag = abs(yfft);
 yprevangle = yangle;
 yangle = angle(yfft);

 % Synthesis Phase Calculation
    % The synthesis phase is calculated by computing the phase increments
    % between successive frequency transforms, unwrapping them, and scaling
    % them by the ratio between the analysis and synthesis hop sizes.
 yunwrap = (yangle - yprevangle) - unwrapdata;
 yunwrap = yunwrap - round(yunwrap/(2*pi))*2*pi;
 yunwrap = (yunwrap + unwrapdata) * Hopratio;
 if firsttime
 ysangle = yangle;
 firsttime = false;
 else
 ysangle = ysangle + yunwrap;
 end

    % Convert magnitude and phase to complex numbers.
 ys = ymag .* complex(cos(ysangle), sin(ysangle));

 % IST-FFT
 yistfft = istft(ys);

 logger(yistfft) % Log signal 
end

release(reader)
release(player)

loggedSpeech = logger.Buffer(200:end)';
player = audioDeviceWriter('SampleRate',Fs, ...
    'SupportVariableSizeInput',true, ...
    'BufferSize',512);
player(loggedSpeech.');

Fs_new = Fs*(SynthesisLen/AnalysisLen);
player = audioDeviceWriter('SampleRate',Fs_new, ...
    'SupportVariableSizeInput',true, ...
    'BufferSize',1024);
player(loggedSpeech.');